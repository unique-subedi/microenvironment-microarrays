---
title: "STATS 604 Project 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cowplot)
library(GGally)
library(gridExtra)
library(tidyverse)
library(tools)
library(vctrs)
```

# Data Loading

Make one tibble with all of the data.
```{r make_all_data, cache=TRUE, message=FALSE}
files <- dir("Data/", full.names = TRUE)
names(files) <- file_path_sans_ext(basename(files))
all_data <- map_dfr(files, read_tsv, .id = "plate")
```

There seems to be just one column with staining set information.
```{r find_ss_cols}
select(all_data, contains("stain"))
```

These are the names of the staining sets.
```{r ss_nms}
unique(all_data$StainingSet)
```

Number the staining sets and the plates.
```{r number_sss_and_plates}
all_data <- all_data %>%
  relocate(StainingSet, .before = 1) %>%
  mutate(
    ss_num = case_when(
      StainingSet == "SS1Layout1Set1" ~ 1L,
      StainingSet == "SS2noH3Layout1Set1" ~ 2L,
      StainingSet == "SS3Layout1Set3" ~ 3L
    )
  ) %>%
  relocate(ss_num, .after = StainingSet) %>%
  group_by(ss_num) %>%
  mutate(plate_num = dense_rank(plate)) %>%
  ungroup() %>%
  relocate(plate_num, .after = plate) %>%
  arrange(ss_num, plate_num)
```

Create one tibble for each staining set.
```{r make_ss_tbls, cache=TRUE}
all_data2 <- nest(all_data, data = !c(StainingSet, ss_num))
with(
  all_data2,
  walk2(
    ss_num, data,
    function(ss_num, data) {
      assign(str_interp("ss${ss_num}_data"), data, .GlobalEnv)
    }
  )
)
```

# Missingness Analysis

For each staining set, there are many columns that only have NAs, seemingly because different variables were measured for different staining sets.
```{r find_na_only_cols}
find_na_only_cols <- function(data) {
  data %>% select(where(~ all(is.na(.x)))) %>% names()
}
all_data2 %>%
  mutate(na_only_cols = map(data, find_na_only_cols)) %>%
  pull()
```

Drop columns that only have missing values.
```{r drop_na_only_cols}
drop_na_only_cols <- function(data) select(data, !where(~ all(is.na(.x))))

all_data <- drop_na_only_cols(all_data)
all_data2 <- mutate(all_data2, data = map(data, drop_na_only_cols))
ss1_data <- drop_na_only_cols(ss1_data)
ss2_data <- drop_na_only_cols(ss2_data)
ss3_data <- drop_na_only_cols(ss3_data)
```

For each staining set, only a few columns have missing values; these columns are the same across staining sets. They are only missing a small proportion of their
values.
```{r find_cols_w_nas}
find_cols_w_nas <- function(data) {
  data %>%
    summarize(across(.fns = ~ mean(is.na(.x)))) %>%
    select(where(~ .x > 0))
}
all_data2 %>% mutate(map(data, find_cols_w_nas)) %>% pull()
```

When an `ECM2` column is missing a value, `ECMp` is collagen, which makes sense.
```{r examine_cols_w_nas}
check_ECM2_cols_w_nas <- function(data) {
  data %>%
    select(ECMp, contains("ECM2")) %>%
    filter(!vec_detect_complete(.)) %>%
    pull(ECMp) %>%
    table() %>%
    proportions() %>%
    sort(decreasing = TRUE) 
}
all_data2 %>% mutate(map(data, check_ECM2_cols_w_nas)) %>% pull()
```

When `ECM1Lx` is missing a value, `ECMp` is either `ELN|3` or `air`. I don't know what to make of this.
```{r examine_cols_w_nas2}
check_ECM1Lx <- function(data) {
  data %>%
    filter(is.na(ECM1Lx)) %>%
    pull(ECMp) %>%
    table() %>%
    proportions() %>%
    sort(decreasing = TRUE)
}
all_data2 %>% mutate(map(data, check_ECM1Lx)) %>% pull()
```

When `Ligand1Lx` is missing a value, `Ligand` is `FGF2|3`. I don't know what to make of this.
```{r examine_cols_w_nas3}
check_Ligand1Lx <- function(data) {
  data %>%
    filter(is.na(Ligand1Lx)) %>%
    pull(Ligand) %>%
    table() %>%
    proportions() %>%
    sort(decreasing = TRUE)
}
all_data2 %>% mutate(map(data, check_Ligand1Lx)) %>% pull()
```

# Structure Checks

There are as many plates as expected.
```{r check_num_plates}
all_data %>% group_by(StainingSet) %>% summarize(num_plates = n_distinct(plate))
```

The name of each plate matches the pattern below.
```{r check_plate_name_pattern}
all_data %>% pull(plate) %>% str_detect("^LI8X005\\d{2}_Level2$") %>% all()
```

The plates are numbered consecutively, except two numbers are skipped. Maybe they were skipped to provide another way to separate the plates into staining sets? The skipped numbers divide the plates into three batches of eight.
```{r check_plate_numbering}
all_data %>%
  pull(plate) %>%
  str_extract("5\\d{2}") %>%
  as.integer() %>%
  {
    seq_ <- seq(min(.), max(.), by = 1)
    setdiff(seq_, .)
  }
```

As expected, there are eight wells for each plate.
```{r check_well_numbers}
all_data %>%
  group_by(StainingSet, plate) %>%
  summarize(num_wells = n_distinct(Well))
```

There are several columns with ligand information. 56 different ligands were used in the experiment. There are several columns with 57 values - probably the extra value represents the absence of a ligand. I'll use `Ligand`.
```{r find_ligand_cols}
summarize(all_data, across(contains("ligand"), n_distinct, na.rm = TRUE))

all_data %>%
  select(contains("ligand") & where(~ n_distinct(.x, na.rm = TRUE) >= 56)) %>%
  distinct()
```

There was one control well on each plate, so there should be one ligand code that is present for each plate. For each ligand variable, the only such code is given below.
```{r find_control_ligand}
all_data %>%
  group_by(plate) %>%
  summarize(ligands = list(unique(Ligand))) %>%
  pull(ligands) %>%
  reduce(intersect)
all_data %>%
  group_by(plate) %>%
  summarize(ligands = list(unique(Ligand1))) %>%
  pull(ligands) %>%
  reduce(intersect)
all_data %>%
  group_by(plate) %>%
  summarize(ligands = list(unique(Ligand1Lx))) %>%
  pull(ligands) %>%
  reduce(intersect)
all_data %>%
  group_by(plate) %>%
  summarize(ligands = list(unique(Ligand1An))) %>%
  pull(ligands) %>%
  reduce(intersect)
```

# Cell Count Analysis

There are no spots at which the cell count is zero.
```{r check_cell_counts}
summarize(all_data, num_zeros = sum(Spot_PA_SpotCellCount == 0))
```

For each plate, make a heatmap showing the cell count for each spot and a histogram of the cell counts. In several plates, there are many white rectangles. Based on the histograms, those appear to be due to many very low counts.
```{r make_heatmaps_and_histograms, cache=TRUE}
make_heatmap <- function(StainingSet, plate, tbl) {
  tbl %>%
    ggplot(aes(ArrayColumn, ArrayRow, fill = Spot_PA_SpotCellCount)) +
    facet_wrap(vars(Well), nrow = 2, labeller = label_both) +
    geom_tile() +
    labs(
      x = "Column Index", y = "Row Index", fill = "Cell Count",
      title = str_c(StainingSet, plate, sep = ", ")
    ) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}
make_histogram <- function(StainingSet, plate, tbl) {
  tbl %>%
    ggplot(aes(Spot_PA_SpotCellCount)) +
    facet_wrap(vars(Well), nrow = 2, labeller = label_both) +
    geom_histogram(binwidth = 1) +
    labs(
      x = "Cell Count", y = "Number of Spots",
      title = str_c(StainingSet, plate, sep = ", ")
    ) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}
all_data %>%
  select(
    StainingSet, plate, Well, ArrayColumn, ArrayRow, Spot_PA_SpotCellCount
  ) %>%
  nest(tbl = !c(StainingSet, plate)) %>%
  mutate(
    heatmap = pmap(list(StainingSet, plate, tbl), make_heatmap),
    histogram = pmap(list(StainingSet, plate, tbl), make_histogram),
    plot = map2(heatmap, histogram, ~ arrangeGrob(.x, .y))
  ) %>%
  with(walk(plot, grid.arrange))
```

# Dimensionality Reduction

## Variable Scales

These seem to be the numeric ID columns; these should be excluded when doing PCA.
```{r find_numeric_id_cols}
numeric_id_cols <- all_data %>%
  select(
    where(is.numeric) &
      !matches("^(Cells|Cytoplasm|Nuclei)_(CP|PA)_") &
      !matches("(Diameter|Conc|TimeReact)$") &
      !matches("^Spot_PA_") &
      !QAScore
  ) %>%
  names()
numeric_id_cols
```

No variable name contains "|".
```{r find_cols_w_pipe}
select(all_data, contains("|"))
```

Define a function for calculating the standard deviations and IQRs of all non-trivial numeric variables in a dataset whose names match a pattern. The output has one row for each variable and columns with the summary statistics.
```{r summary_stats_funcs}
calc_summary_stats <- function(data, pattern = ".*") {
  data %>%
    select(
      where(is.numeric) &
        where(~ !any(is.na(.x))) &
        where(~ n_distinct(.x) > 1) &
        !any_of(numeric_id_cols) &
        matches(pattern)
    ) %>%
    summarize(
      across(.fns = list(sd = sd, iqr = IQR), .names = "{.col}|{.fn}")
    ) %>%
    pivot_longer(
      cols = everything(), names_to = c("col", ".value"), names_sep = "\\|"
    )  
}

make_summary_stats_plot <- function(summary_stats, title) {
  sd_panel <- summary_stats %>%
    mutate(log_sd = log10(sd - min(sd) + 1)) %>%
    ggplot(aes(log_sd)) +
    geom_histogram(color = "black", fill = "lightgray", bins = 10) +
    labs(x = "Log Standard Deviation", y = "Number of Variables") +
    theme_bw()
  iqr_panel <- summary_stats %>%
    mutate(log_iqr = log10(iqr - min(iqr) + 1)) %>%
    ggplot(aes(log_iqr)) +
    geom_histogram(color = "black", fill = "lightgray", bins = 10) +
    labs(x = "Log IQR", y = "Number of Variables") +
    theme_bw()
  arrangeGrob(sd_panel, iqr_panel, nrow = 1, top = title)
}
```

The histograms below show the log-transformed standard deviations and IQRs of all of the variables. For each staining set, there is a fair amount of variation in scale across variables - some variables are on a much larger scale than others. This means that rescaling before performing PCA is absolutely necessary. Otherwise, the top PCs will largely reflect the variables with the largest scales. For each staining set, the five variables with the largest standard deviations are also shown.
```{r summary_stats, message=FALSE}
all_summary_stats <- all_data2 %>%
  mutate(
    summary_stats = map(data, calc_summary_stats),
    title = map_chr(
      ss_num, ~ str_interp("Staining Set ${.x} Summary Statistics")
    ),
    summary_stats_plot = map2(summary_stats, title, make_summary_stats_plot)
  )

with(all_summary_stats, walk(summary_stats_plot, grid.arrange))

all_summary_stats %>%
  mutate(
    summary_stats = map(
      summary_stats, ~ slice(arrange(.x, desc(sd)), n = 1:5)
    )
  ) %>%
  select(ss_num, summary_stats) %>%
  unnest(summary_stats) %>%
  print(n = 15)

rm(all_summary_stats)
```

The histograms below show the log-transformed standard deviations and IQRs of the AreaShape variables. We again see that the variables differ in scale substantially. 
```{r areashape_summary_stats, message=FALSE}
all_summary_stats <- all_data2 %>%
  mutate(
    summary_stats = map(data, calc_summary_stats, pattern = "AreaShape"),
    title = map_chr(
      ss_num, ~ str_interp("Staining Set ${.x} AreaShape Summary Statistics")
    ),
    summary_stats_plot = map2(summary_stats, title, make_summary_stats_plot)
  )

with(all_summary_stats, walk(summary_stats_plot, grid.arrange))

all_summary_stats %>%
  mutate(
    summary_stats = map(
      summary_stats, ~ slice(arrange(.x, desc(sd)), n = 1:5)
    )
  ) %>%
  select(ss_num, summary_stats) %>%
  unnest(summary_stats) %>%
  print(n = 15)

rm(all_summary_stats)
```

## PCA

Define functions for running PCA and plotting the results of PCA.
```{r pca_funcs}
run_pca <- function(data, pattern = ".*") {
  data %>%
    select(
      where(is.numeric) &
        where(~ !any(is.na(.x))) &
        where(~ n_distinct(.x) > 1) &
        !any_of(numeric_id_cols) &
        matches(pattern)
    ) %>%
    prcomp(scale. = TRUE)
}

make_prop_var_explained_plot <- function(pca_results, title) {
  plot <- pca_results %>%
    `$`("sdev") %>%
    `^`(2) %>%
    {cumsum(.) / sum(.)} %>%
    enframe(name = "num_pcs", value = "prop_var_explained") %>%
    ggplot(aes(num_pcs, prop_var_explained)) +
    geom_point() +
    geom_line() +
    geom_hline(linetype = "dashed", yintercept = 0.95) +
    labs(
      x = "Number of PCs", y = "Proportion of Variation Explained",
      title = title
    ) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
  brks <- layer_scales(plot)$y$get_breaks()
  plot + scale_y_continuous(breaks = c(brks, 0.95))
}

make_first_pc_loadings_plot <- function(pca_results, title) {
  pca_results %>%
    `$`("rotation") %>%
    `[`(, "PC1") %>%
    enframe(name = "col", value = "loading") %>%
    ggplot(aes(loading)) +
    geom_histogram(color = "black", fill = "lightgray", binwidth = 0.01) +
    labs(x = "Loading", y = "Number of Variables", title = title) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}

make_first_2_pcs_loadings_plot_no_pattern <- function(pca_results, title) {
  pca_results %>%
    `$`("rotation") %>%
    `[`(, c("PC1", "PC2")) %>%
    as_tibble(rownames = "col") %>%
    rename(loading1 = PC1, loading2 = PC2) %>%
    ggplot(aes(loading1, loading2)) +
    geom_point() +
    labs(x = "PC1 Loading", y = "PC2 Loading", title = title) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}

make_first_2_pcs_loadings_plot_pattern <- function(pca_results,
                                                    pattern,
                                                    title) {
  pca_results %>%
    `$`("rotation") %>%
    `[`(, c("PC1", "PC2")) %>%
    as_tibble(rownames = "col") %>%
    rename(loading1 = PC1, loading2 = PC2) %>%
    mutate(
      col_parts = str_split(col, "_"),
      subset1 = map_chr(col_parts, 1),
      subset2 = map_chr(col_parts, 3)
    ) %>%
    select(!col_parts) %>%
    select(where(~ !all(str_detect(.x, pattern)))) %>%
    rename_with(str_remove, starts_with("subset"), pattern = "\\d$") %>%
    ggplot(aes(loading1, loading2, color = subset)) +
    geom_point() +
    labs(
      x = "PC1 Loading", y = "PC2 Loading",
      color = "Subset",
      title = title
    ) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
}

make_first_2_pcs_loadings_plot <- function(pca_results, pattern = ".*", title) {
  if (pattern == ".*") {
    make_first_2_pcs_loadings_plot_no_pattern(pca_results, title)
  } else {
    make_first_2_pcs_loadings_plot_pattern(pca_results, pattern, title)
  }
}
```

The plots below show that the first 20-30 PCs capture around 95\% of the variation for each staining set.
```{r pca}
all_data2 %>%
  mutate(
    pca_results = map(data, run_pca),
    title = map_chr(
      ss_num, ~ str_interp("PCA for Staining Set ${.x}")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num, ~ str_interp("PC1 Loadings for Staining Set ${.x}")
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num, ~ str_interp("PC1, PC2 Loadings for Staining Set ${.x}")
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = ".*"
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

```{r pca_by_plate, eval=FALSE, include=FALSE}
all_data %>%
  nest(data = !c(ss_num, plate_num)) %>%
  mutate(
    pca_results = map(data, run_pca, pattern = "AreaShape"),
    title = map2_chr(
      ss_num, plate_num,
      ~ str_interp("AreaShape PCA for Plate ${.y} of Staining Set ${.x}")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    )
  ) %>%
  with(walk(prop_var_explained_plot, print))
```

Define a function that counts non-trivial numeric columns whose names match a pattern.
```{r count_cols}
count_cols <- function(data, pattern) {
  data %>%
    select(
      where(is.numeric) &
        where(~ !any(is.na(.x))) &
        where(~ n_distinct(.x) > 1) &
        !any_of(numeric_id_cols) &
        matches(pattern)
    ) %>%
    ncol()
}
```

### PCA by Variable Class

For each class of columns, count columns by staining set. Some classes don't appear in all staining sets. For others, the counts differ substantially across staining sets.
```{r col_counts_by_class}
all_data2 %>%
  mutate(
    num_areashape_cols = map_int(data, count_cols, pattern = "AreaShape"),
    num_intensity_cols = map_int(data, count_cols, pattern = "Intensity"),
    num_cycle_cols = map_int(data, count_cols, pattern = "Cycle"),
    num_gated_cols = map_int(data, count_cols, pattern = "Gated"),
    num_texture_cols = map_int(data, count_cols, pattern = "Texture")
  ) %>%
  select(!c(StainingSet, ss_num, data)) %>%
  print(width = 100)
```

Looking only at the AreaShape variables, fewer than ten PCs account for over 95\% of the variation. In particular, for staining set 2, just four PCs account for that percentage of the variation. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r areashape_pca}
pattern <- "AreaShape"
all_data2 %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

We next consider the Intensity variables. For staining sets 1 and 2, around five PCs capture 95\% of the variation. However, for staining set 3, 12-13 PCs are needed. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r intensity_pca}
pattern <- "Intensity"
all_data2 %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

For the Cycle variables, for each staining set, the top two PCs account for all of the variation.  Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r cycle_pca}
pattern <- "Cycle"
all_data2 %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

We next consider the Gated variables, which weren't measured for staining set 1. For staining set 2, all PCs are needed to capture 95\% of the variation. For staining set 3, five PCs are needed. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r gated_pca}
pattern <- "Gated"
all_data2 %>%
  filter(ss_num != 1) %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

The Texture variables were only measured for staining set 2. Six PCs account for 95\% of the variation. The plot of the PC1 and PC2 loadings seems to suggest that the variables can be partitioned into three clusters.
```{r texture_pca}
pattern <- "Texture"
all_data2 %>%
  filter(ss_num == 2) %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

### PCA by Cell Part

For each cell part, count columns by staining set. As before, some classes don't appear in all staining sets. For others, the counts differ substantially across staining sets.
```{r col_counts_by_cell_part}
all_data2 %>%
  mutate(
    num_cells_cols = map_int(data, count_cols, pattern = "Cells"),
    num_cytoplasm_cols = map_int(data, count_cols, pattern = "Cytoplasm"),
    num_nuclei_cols = map_int(data, count_cols, pattern = "Nuclei")
  ) %>%
  select(!c(StainingSet, ss_num, data))
```

Looking at the Cells variables, for staining set 1, the first seven PCs account for 95\% of the variation. For staining set 3, the number is nine. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r cells_pca}
pattern <- "Cells"
all_data2 %>%
  filter(ss_num != 2) %>%
  mutate(
    pca_results = map(data, run_pca, pattern = "Cells"),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

Looking at the Cytoplasm variables, for staining set 1, the first eight PCs account for 95\% of the variation. For staining set 3, the number is 15. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r cytoplasm_pca}
pattern <- "Cytoplasm"
all_data2 %>%
  filter(ss_num != 2) %>%
  mutate(
    pca_results = map(data, run_pca, pattern = "Cytoplasm"),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

Looking at the Nuclei variables, for staining set 1, the first seven PCs account for 95\% of the variation. For staining set 2, the number is around 17. For staining set 3, the number is 11. Plots of the PC1 and PC2 loadings don't seem to reveal anything.
```{r nuclei_pca}
pattern <- "Nuclei"
all_data2 %>%
  mutate(
    pca_results = map(data, run_pca, pattern = pattern),
    title = map_chr(
      ss_num,
      ~ str_interp("PCA for Staining Set ${.x}, ${pattern} Variables Only")
    ),
    prop_var_explained_plot = map2(
      pca_results, title, make_prop_var_explained_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_pc_loadings_plot = map2(
      pca_results, title, make_first_pc_loadings_plot
    ),
    title = map_chr(
      ss_num,
      ~ str_interp(
        "PC1, PC2 Loadings for Staining Set ${.x}, ${pattern} Variables Only"
      )
    ),
    first_2_pcs_loadings_plot = map2(
      pca_results, title, make_first_2_pcs_loadings_plot, pattern = pattern
    )
  ) %>%
  with(
    {
      walk(prop_var_explained_plot, print)
      walk(first_pc_loadings_plot, print)
      walk(first_2_pcs_loadings_plot, print)
    }
  )
```

# Delete/update chunks below

```{r eval=FALSE, include=FALSE}
data %>%
  distinct(plate, Well, Ligand) %>%
  arrange(Well, Ligand)

data %>%
  filter(StainingSet == unique(StainingSet)[1]) %>%
  distinct(Well, Ligand) %>%
  arrange(Well, Ligand)

LI8X00510_Level2 %>%
  select(Well, contains("ligand")) %>%
  distinct()

data %>%
  select(StainingSet, plate, Well, contains("ligand")) %>%
  distinct() %>%
  arrange(StainingSet, plate, Well) %>%
  nest(tbl = !c(StainingSet, plate)) %>%
  group_by(StainingSet) %>%
  summarize(num_tbls = n_distinct(tbl))

# Same ligand positionings for each StainingSet
data %>%
  select(StainingSet, plate, Well, contains("ligand")) %>%
  distinct() %>%
  arrange(StainingSet, plate, Well) %>%
  nest(tbl = !c(StainingSet, plate)) %>%
  group_by(StainingSet) %>%
  summarize(tbls = list(tbl)) %>%
  pull(tbls) %>%
  n_distinct()
```

There are no missing values in `ArrayRow` or `ArrayColumn`.
```{r nas_in_array_row_col, eval=FALSE, include=FALSE}
data %>%
  select(ArrayRow, ArrayColumn) %>%
  vec_detect_complete() %>%
  all()
```

`Spot` is related to `ArrayRow` and `ArrayColumn` in the expected way.
```{r spot_arrayrow_arraycol, eval=FALSE, include=FALSE}
map_lgl(
  tbls,
  ~ .x %>%
    mutate(Spot2 = max(ArrayColumn) * (ArrayRow - 1) + ArrayColumn - 1) %>%
    summarize(are_equal = all(near(Spot2, Spot - 1))) %>%
    pull()
) %>%
  all()
```

The filenames and barcodes are essentially the same.
```{r barcodes, eval=FALSE, include=FALSE}
imap_lgl(
  tbls,
  ~ identical(unique(.x$Barcode), str_remove(.y, "_Level2$"))
) %>%
  all()
```

The ECM2 columns are the same across all wells.
```{r ECM2, eval=FALSE, include=FALSE}
map(
  tbls,
  ~ unique(select(.x, contains("ECM2")))
) %>%
  unique()
```

As expected, each plate has one stain.
```{r num_staining_sets_per_plate, eval=FALSE, include=FALSE}
map(tbls, ~ n_distinct(.x$StainingSet)) %>% unique()
```

There are eight plates for each stain.
```{r num_plates_per_staining_set, eval=FALSE, include=FALSE}
map_chr(tbls, ~ .x$StainingSet[1]) %>% table()
```

Plates with the same staining set have the same variables.
```{r var_name_sets, eval=FALSE, include=FALSE}
tbls %>%
  map_dfr(
    function(tbl) {
      tibble(StainingSet = tbl$StainingSet[1], var_names = list(names(tbl)))
    }
  ) %>%
  group_by(StainingSet) %>%
  summarize(num_var_name_sets = n_distinct(var_names))
```

There are three count columns in each file.
```{r count_count_cols, eval=FALSE, include=FALSE}
map(
  tbls,
  ~ names(select(.x, contains("count")))
) %>%
  unique()
```

`Spot_PA_SpotCellCount_SE` always equals zero.
```{r Spot_PA_SpotCellCount_SE, eval=FALSE, include=FALSE}
map_lgl(
  tbls,
  . %>% pull(Spot_PA_SpotCellCount_SE) %>% near(0) %>% all()
) %>%
  all()
```

`Spot_PA_ReplicateCount` seems to have something to do with the reuse of ECMPs within wells since its maximum value is 15. How should this column be interpreted?
```{r Spot_PA_ReplicateCount, eval=FALSE, include=FALSE}
map(
  tbls,
  . %>%
    pull(Spot_PA_ReplicateCount) %>%
    table() %>%
    proportions() %>%
    sort(decreasing = TRUE) %>%
    cumsum() %>%
    signif(digits = 2)
)
```

```{r, eval=FALSE, include=FALSE}
map_dfr(
  tbls,
  ~ summarize(
    .x,
    stain = StainingSet[1],
    num_nas = sum(is.na(Spot_PA_SpotCellCount)),
    min_ct = min(Spot_PA_SpotCellCount, na.rm = TRUE),
    max_ct = max(Spot_PA_SpotCellCount, na.rm = TRUE),
  ),
  .id = "tbl"
)
```

The cell count distributions for the different staining sets are quite different.
```{r cell_count_dists, eval=FALSE, include=FALSE}
tbls %>%
  map_dfr(~ select(.x, StainingSet, Spot_PA_SpotCellCount), .id = "tbl") %>%
  ggplot(aes(Spot_PA_SpotCellCount, color = StainingSet)) +
  geom_freqpoly() +
  labs(x = "Cell Count", y = "Number of Spots", color = "Staining Set") +
  theme_bw()
```

For this one plate, the counts for well 3 are lower than for the other wells. There are also fewer spots for that well than for the other wells.
```{r one_plate_heatmap, eval=FALSE, include=FALSE}
LI8X00510_Level2 %>%
  ggplot(aes(ArrayColumn, ArrayRow, fill = Spot_PA_SpotCellCount)) +
  facet_wrap(vars(Well), nrow = 2, labeller = label_both) +
  geom_tile() +
  labs(x = "Column Index", y = "Row Index", fill = "Cell Count") +
  theme_bw()
```

```{r dists_by_ligand, eval=FALSE, include=FALSE}
data %>%
  ggplot(aes(Ligand, Spot_PA_SpotCellCount)) +
  geom_boxplot() +
  theme_bw()
data %>%
  ggplot(aes(Ligand, Cells_CP_AreaShape_Area)) +
  geom_boxplot() +
  theme_bw()
data %>%
  ggplot(aes(Ligand, Cells_CP_AreaShape_Perimeter)) +
  geom_boxplot() +
  theme_bw()
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
data %>%
  filter(Ligand == "FBS") %>%
  select(StainingSet, ECMp, plate, Spot_PA_SpotCellCount) %>%
  arrange(StainingSet, ECMp, plate) %>%
  filter(ECMp == "air") %>%
  arrange(plate)
```


```{r, echo=FALSE, eval=FALSE, include=FALSE}
data %>%
  select(StainingSet, plate, Ligand, Spot_PA_SpotCellCount) %>%
  count(StainingSet, plate, Ligand) %>%
  pivot_wider(id_cols = Ligand, names_from = StainingSet, values_from = n)

data %>%
  select(StainingSet, plate, Ligand, Spot_PA_SpotCellCount) %>%
  filter(
    StainingSet == "SS1Layout1Set1",
    plate == "LI8X00519_Level2",
    Ligand == "ANGPT1|1"
  )

data %>%
  distinct(StainingSet, Ligand, Spot_PA_SpotCellCount) %>%
  filter(Ligand == "ANGPT1|1", StainingSet == "SS2noH3Layout1Set1")

data %>%
  distinct(StainingSet, Ligand, Spot_PA_SpotCellCount) %>%
  filter(Ligand == "ANGPT1|1", StainingSet == "SS3Layout1Set3")

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  
```

```{r, eval=FALSE, include=FALSE}
# Too many variables
data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(starts_with("Cells_CP_AreaShape_")) %>%
  select(
    -c(Cells_CP_AreaShape_Extent, Cells_CP_AreaShape_FormFactor,
       Cells_CP_AreaShape_Orientation, Cells_CP_AreaShape_Solidity)
  ) %>%
  pairs()

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(starts_with("Cells_CP_AreaShape_")) %>%
  rename_with(str_remove, pattern = "^Cells_CP_AreaShape_") %>%
  select(Area, Compactness, Eccentricity) %>%
  ggpairs(aes(alpha = 0.1)) +
  theme_bw()

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(starts_with("Cells_CP_AreaShape_")) %>%
  rename_with(str_remove, pattern = "^Cells_CP_AreaShape_") %>%
  select(Area, Compactness, Eccentricity) %>%
  mutate(across(.fns = ~ qnorm(rank(.x) / (n() + 1)))) %>%
  ggpairs() +
  theme_bw()

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(starts_with("Cells_CP_AreaShape_")) %>%
  rename_with(str_remove, pattern = "^Cells_CP_AreaShape_") %>%
  select(Compactness, Eccentricity) %>%
  ggplot(aes(Compactness, Eccentricity)) +
  geom_point(alpha = 0.1) +
  coord_cartesian(xlim = c(1, 2)) +
  theme_bw()

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(starts_with("Cells_CP_AreaShape_")) %>%
  rename_with(str_remove, pattern = "^Cells_CP_AreaShape_") %>%
  select(Compactness, Eccentricity) %>%
  mutate(across(.fns = ~ qnorm(rank(.x) / (n() + 1)))) %>%
  ggplot(aes(Compactness, Eccentricity)) +
  geom_point(alpha = 0.1) +
  theme_bw()
```

```{r, eval=FALSE, include=FALSE}
calc_cor <- function(ligand, ecmp, var1, var2) {
  
}
```


```{r, eval=FALSE, include=FALSE}
data1 <- data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(where(~ any(!is.na(.x)))) %>%
  select(plate, Ligand, ECMp, where(is.numeric))
data1 %>%
  select(where(is.numeric)) %>%
  names() %>%
  expand_grid(var1 = ., var2 = .) %>%
  filter(var1 != var2) %>%
  mutate(
    var1_vals = map(var1, ~ data1[[.x]]), var2_vals = map(var2, ~ data1[[.x]])
  )
data1 %>%
  select()
```


```{r, eval=FALSE, include=FALSE}
data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  select(plate, Ligand, ECMp, Spot_PA_SpotCellCount, contains("AreaShape"))
```

```{r, eval=FALSE, include=FALSE}
data %>%
  select(StainingSet, contains("neighbor")) %>%
  ggplot(aes(Nuclei_PA_AreaShape_Neighbors, color = StainingSet)) +
  geom_freqpoly() +
  theme_bw()

data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  ggplot(aes(Nuclei_PA_AreaShape_Neighbors)) +
  geom_histogram() +
  theme_bw()

data %>%
  select(StainingSet, contains("neighbor")) %>%
  group_by(StainingSet) %>%
  summarize(
    neighbors_dist = list(
      sort(table(Nuclei_PA_AreaShape_Neighbors), decreasing = TRUE)
    )
  ) %>%
  deframe()
```

```{r, eval=FALSE, include=FALSE}
data %>%
  filter(StainingSet == "SS1Layout1Set1") %>%
  rename_with(str_remove, pattern = "^Cells_CP_AreaShape_") %>%
  select(Ligand, ECMp, Area, Perimeter) %>%
  arrange(Ligand, ECMp) %>%
  group_by(Ligand, ECMp) %>%
  mutate( # How should ties be broken when ranking?
    cor = cor(Area, Perimeter),
    Area2 = qnorm(rank(Area) / (n() + 1)),
    Perimeter2 = qnorm(rank(Perimeter) / (n() + 1)),
    cor2 = cor(Area2, Perimeter2),
    num_replicates = n()
  ) %>%
  ungroup() %>%
  filter(num_replicates >= 10) %>%
  distinct(Ligand, ECMp, cor2) %>%
  ggplot(aes(cor2)) +
  geom_histogram() +
  theme_bw()
```